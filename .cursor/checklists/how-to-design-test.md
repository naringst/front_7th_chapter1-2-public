## 1. 테스트는 명세처럼 읽혀야 한다

- 테스트는 “코드 검증”이 아니라 “명세 문서”처럼 읽혀야 한다.
- 테스트 이름은 **행동 + 기대 결과** 형식으로 작성한다.
  ```
  it('잘못된 비밀번호 입력 시 에러 메시지를 표시한다', ...)
  it('반복 일정 생성 시 아이콘이 표시된다', ...)

  ```
- 내부 로직보다 **사용자 관점의 결과**에 초점을 맞춘다.

---

## 2. AAA 패턴(Arrange – Act – Assert)을 따른다

테스트의 기본 구조는 다음과 같다.

```
1. Arrange (준비): 테스트 환경, 입력값, mock 세팅
2. Act (실행): 테스트할 실제 동작 수행
3. Assert (검증): 기대 결과 확인

```

예시:

```tsx
it('유효한 이메일과 비밀번호로 로그인하면 성공 메시지를 표시한다', async () => {
  // Arrange
  render(<LoginPage />);
  await user.type(screen.getByLabelText('이메일'), 'user@example.com');
  await user.type(screen.getByLabelText('비밀번호'), '1234');

  // Act
  await user.click(screen.getByText('로그인'));

  // Assert
  expect(await screen.findByText('환영합니다')).toBeInTheDocument();
});
```

- 이 순서를 지키면 테스트가 문서처럼 읽히고, 디버깅이 쉬워진다.
- `beforeEach`는 **Arrange 일부를 공통화**하는 용도로만 사용한다.

---

## 3. 하나의 테스트는 하나의 목적만 검증한다

- 각 테스트(`it`)는 **하나의 개념적 목적만** 검증해야 한다.
- 여러 개의 `expect`를 써도 좋지만, 모두 같은 시나리오 내에서만 사용한다.
- 서로 다른 기능이나 흐름을 한 테스트에 섞지 않는다.

---

## 4. 테스트 간 독립성을 보장한다

- 테스트 실행 순서가 달라져도 결과가 같아야 한다.
- `beforeEach`로 공통 세팅을 하되, 상태 공유는 금지한다.
- Mock, DOM, 전역 상태는 테스트마다 새로 생성한다.

---

## 5. Mocking은 최소한으로만 사용한다

- Mock은 외부 의존(API, DB, 네트워크 등)에 한정한다.
- Mock이 많을수록 실제 코드 대신 Mock을 테스트하게 된다.
- 가능한 실제 로직을 실행하고, side effect가 있는 부분만 Mock한다.

---

## 6. 입력과 출력이 명확한 단위를 테스트한다

- “예측 가능한 결과를 내는 함수(순수 함수)”는 반드시 단위 테스트한다.
- 조건 분기, 계산, 변환 로직은 단위 테스트 대상이다.
- DOM, 상태관리, API 통신 등 외부 의존이 포함된 로직은 통합 테스트로 다룬다.

---

## 7. 테스트 이름과 구조는 일관되어야 한다

| 구분       | 규칙                   | 예시                                                |
| ---------- | ---------------------- | --------------------------------------------------- |
| 파일명     | `{feature}.spec.tsx`   | `login.spec.tsx`                                    |
| `describe` | `"기능명 Feature"`     | `"Login Feature"`                                   |
| `it`       | `"TC-01 - 시나리오명"` | `"TC-01 - 유효한 로그인 시 성공 메시지를 표시한다"` |

---

## 8. 불필요한 `waitFor`, `act` 사용을 피한다

- 명확한 이벤트(클릭, 입력 등) 이후에만 `waitFor`를 사용한다.
- 타이밍 보정용 `waitFor`는 불안정하고 느린 테스트를 만든다.

---

## 9. Magic number와 하드코딩된 문자열을 피한다

- 의미 없는 숫자나 문자열은 상수나 변수명으로 명확히 표현한다.
  ```tsx
  const INVALID_PASSWORD = 'wrong_password';
  const VALID_EMAIL = 'user@example.com';
  ```

---

## 10. UI 테스트는 사용자 행동 기반으로 작성한다

- React Testing Library의 철학: “사용자가 보는 화면을 그대로 테스트하라.”
- DOM 구조나 내부 구현이 아니라 **사용자 행동과 결과**를 검증한다.
  ```tsx
  await user.type(screen.getByLabelText('이메일'), 'user@example.com');
  await user.click(screen.getByText('로그인'));
  expect(await screen.findByText('환영합니다')).toBeInTheDocument();
  ```

---

## 11. 테스트는 실패했을 때 원인을 바로 파악할 수 있어야 한다

- 실패 메시지를 통해 “무엇이 잘못됐는지” 바로 알 수 있어야 한다.
- helper나 abstraction이 많으면 의도가 흐려지므로 피한다.
- 테스트는 독립적으로 읽히는 문장처럼 구성한다.

---

## 12. 테스트 코드도 리팩토링 가능한 코드다

- 테스트는 제품 코드와 동일한 수준의 품질로 관리해야 한다.
- 반복되는 setup은 공통화하되, 가독성이 우선이다.
- DRY(Don’t Repeat Yourself)보다 “의도가 드러나는 중복”이 더 낫다.

---

## 13. 단위 테스트와 통합 테스트의 역할을 구분한다

| 구분                     | 목적                  | 특징           | 예시                   |
| ------------------------ | --------------------- | -------------- | ---------------------- |
| 단위(Unit) 테스트        | 순수 로직 검증        | 빠르고 독립적  | 날짜 계산, 유효성 검사 |
| 통합(Integration) 테스트 | 로직 간 상호작용 검증 | 실제 흐름 중심 | 컴포넌트 + API 호출    |

---

## 14. 좋은 테스트의 3대 원칙

| 원칙     | 설명                          | 목표               |
| -------- | ----------------------------- | ------------------ |
| Fast     | 빠르게 실행되어야 한다        | 테스트 피드백 속도 |
| Isolated | 다른 테스트에 영향받지 않는다 | 순서 의존 제거     |
| Readable | 누구나 의도를 이해할 수 있다  | 문서처럼 읽힘      |

---

## 15. Kent Beck의 테스트 철학을 따른다

- 테스트는 명확하고 간결해야 한다.
- 한 테스트는 하나의 의도만 가져야 한다.
- 실행 순서나 내부 구현에 의존하지 않는다.
- 불필요한 Mock, setup, 중복을 제거한다.
- 테스트는 “설계 품질의 피드백 루프”다.

---

## 16. 테스트는 제품 품질의 일부다

- 테스트는 버그를 찾기 위한 도구가 아니라 **설계를 검증하는 문서**다.
- TDD로 작성된 테스트는 더 나은 설계를 이끌어낸다.
- 좋은 테스트는 유지보수 속도와 신뢰도를 높인다.

---
